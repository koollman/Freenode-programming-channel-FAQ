# Freenode programming channel FAQ

This page is intended to be global for the whole [##programming](irc://irc.freenode.net/##programming) channel. So feel free to clone and reuse.

## The Questions

###   How do I talk on the channel?

In order to talk on ##programming, connect your IRC client to the irc.freenode.net server, type «/join ##programming» (without the angle brackets) and press enter. It is a good idea to register your nickname with the Freenode network (see /msg NickServ HELP). This URL may work for you: <a href="irc://irc.freenode.net/##programming">irc://irc.freenode.net/##programming</a> .

Freenode also provides a web interface here: <a href="http://webchat.freenode.net/">http://webchat.freenode.net/</a> . For more information about viable IRC clients see:

* <a href="http://perl-begin.org/irc/">http://perl-begin.org/irc/</a>
* [List of Networking Clients](http://www.shlomifish.org/open-source/resources/networking-clients/)
* [http://en.wikipedia.org/wiki/List\_of\_IRC\_clients](http://en.wikipedia.org/wiki/List_of_IRC_clients)

###   What is considered on-topic on ##programming? What is considered off-topic?

Well, we try to concentrate on programming and related Computer Science-related discussions, but sometimes discussions diverge into something different and we're OK with it. Some things that are on-topic:

1. Getting help with specific programming languages technologies, including those that have dedicated channels on Freenode and/or elsewhere, including but not limited to Java, C#/.NET, PHP, Visual Basic (Classic, .NET, Visual Basic for Applications, or whatever), C++, C, Python, Perl, Ruby, JavaScript or whatever. We do not intend to imply we endorse using any of these technologies (and different members of the channels may have different opinions of them) but we still support them.
2. Help with someone's programming or CS homework is also on-topic on ##programming . It is considered unethical to write your homework for you, but you can get different kinds of help.

The reason we agree to discuss such things as discussing such things help the channel grow, make the content of the channel more lively and interesting, and because the traffic generated by them is still not overwhelming enough for us to consider a different policy. (Also see [what “Joel on Software” said about Internet forums becoming too fragmented](http://www.joelonsoftware.com/items/2004/09/03.html).).

Some discussions that are explicitly off-topic:

1. Discussions about global/national politics — these tend to deteriorate very quickly, and many people find them annoying. If you still wish to discuss them, head over to [\#politics](irc://irc.freenode.net/#politics).
2. Discussions about religion for similar reasons.
3. Personal insults, [Ad hominem](http://en.wikipedia.org/wiki/Ad_hominem) attacks, sexual/racial/political harassment, etc.
4. Illegal activity (as forbidden by Freenode policy).

None of these things will get you banned immediately, but you will be warned and told to stop, and devoiced only if you persist.

###   I tried joining a different channel for help, but I could not - why?

Some channels people try to join to seek help with their technology (notably ##java) require registration at the Freenode services. See [Freenode’s knowledge base](http://freenode.net/kb/all) for more information about user/nickname registration.

Note that you are still welcome to ask questions related to specific technologies on ##programming, but otherwise you'll probably get more help on the topic-specific channels.

###   Which Integrated Development Environment (IDE) or Text Editor Would You Recommend?

We get asked this question a lot. The answer is a bit long. First of all, it is likely that the following editing mechanisms will not be adequate for editing code:

* Rich-text editors including, but not limited to, Microsoft Windows WordPad (formerly known as Windows Write, we were informed that it has a text editing mode, but see below), word processors such as Microsoft Word, OpenOffice.org/LibreOffice Writer, WordPerfect, AbiWord, etc. and WYSIWYG (= "What you see is what you get") HTML editors. These are not suitable for editing code.
* Limited text editors such as Microsoft Windows Notepad (see <http://www.notepad.org/> for a very fun link about it ), or [Pico](https://en.wikipedia.org/wiki/Pico_%28text_editor%29) which are aimed for casual editing of text documents. More capable text editors such as [Notepad++](http://notepad-plus-plus.org/), [Notepad2](http://www.flos-freeware.ch/notepad2.html) and [GNU Nano](http://www.nano-editor.org/), should be OK.

These editors may still be useful if that's all you can use, but if you can afford to install and/or use a more capable text editor, it is, by all means, a good idea.

Otherwise, asking the channel about the most recommend text editor will end up in people giving you their own preferences (which may have involved many years of trying different solutions, and dedicating some time to studying their existing preference and getting accustomed to it). Some links to get you started:

* [The “List of Text Editors and IDEs”](http://www.shlomifish.org/open-source/resources/editors-and-IDEs/) on Shlomi Fish’s homepage. (Not complete, but covers the most prominent solutions).
* [The Text Editors Wiki](http://texteditors.org/)

Note that many decent text editors and IDEs are open-source, free-of-charge, and cross-platform (Windows, Mac OS X and Linux/UNIX). As a result, there is no good excuse not to download one, install it, and use it.

###   I want to learn programming? Which language should I start with?

Different people will give different answers when asked that. Most people on ##programming believe that something like [the Python programming language](https://en.wikipedia.org/wiki/Python_%28programming_language%29) would be a good start. Python is a popular, useful, open source, and cross-platform (runs fine on Windows, Linux and Mac OS X and on many other less common platforms), that is not too hard to learn and get your feet wet with. Some resources to learn Python are:

* [_Learn Python the Hard Way_](http://learnpythonthehardway.org/) - while it has an intimidating title, this book aims to teach beginning programmers proper programming using Python using formal methods.
* [_How to think like a computer scientist - Learning in Python_](http://openbookproject.net/thinkcs/python/english2e/) - a similar book.
* [The Default Python Tutorial](http://docs.python.org/tutorial/) - may not be too useful for people with no programming experience.

Here are some resources for learning other programming languages, whether as a first language or after knowing some other languages:

* [The C/C++ Beginners' Wiki](http://c-begin.wikia.com/wiki/C_and_C%2B%2B_Beginners_Wiki) and the more mature (but with a non-clear licence) [Freenode ##C Wiki](http://www.iso-9899.info/).
* [The Perl Beginners Site](http://perl-begin.org/) for Perl beginners.

###   How should I do binary Input/Output properly?

Some people would naïvely assume that writing a C struct directly to a file would be a good solution for outputting it to disk. That is far from the case, however. The representation of a struct in memory is subject to many system-dependent factors, such as:

* [Endianness](http://en.wikipedia.org/wiki/Endianness) - also referred to as byte sex, this determines whether bytes are stored in memory with the lowest byte first or the highest one.
* Padding - for efficiency reasons, compilers tend to place empty spaces between the fields of structs. The amount of such space is not standardised and varies between systems, compilers (and even compilation options can affect it).
* Integral data types and pointers can vary in their nominal size. I.e: an "int" can be 16-bit, 32-bit, or 64-bit, a "long" can be 32-bit or 64-bit, etc., which is system-dependent.

The O’Reilly book [Porting UNIX Software](http://www.lemis.com/grog/Documentation/PUS/) (available for purchase or download under a Creative Commons licence on the link), goes into further depth about these and many other UNIX portability issues.

In any case, the best way to mitigate this problem portably and safely, is to write (and later read) every field (and sometimes every byte within) to the disk or network. You should be able to find some mechanisms inside [portable libraries](http://www.shlomifish.org/open-source/portability-libs/) to do that.

###   What are some best practices in programming that I should adopt?

First of all, we should note that many best practices may still be controversial to a small or large extent, despite being very common in the industry. We also don't expect a beginning programmer who writes some simple programs to immediately employ all the best practices that go into developing mission-critical software on which lives are dependent.

But here goes with a grain of salt:

1. Use a good [version control system](http://en.wikipedia.org/wiki/Revision_control). For more about version control systems and the motivation behind them see [the “Better SCM” Site](http://better-scm.shlomifish.org/) and [a related section from “Perl for Perl Newbies”](http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/version-control/) (which is not exclusively limited to Perl) and [Sawyer X’s talk about source code management systems](http://www.slideshare.net/xSawyer/source-code-management-systems).
  * Please don't give the usual cliches that you don't need a version control system if you’re only one person or that the project is not large enough to warrant it. You probably do.
2. Write Automated Tests. See [Test-driven development](http://en.wikipedia.org/wiki/Test-driven_development) and other resources.
3. Use a standard build/configuration system for the language you use. Simple [makefiles](http://en.wikipedia.org/wiki/Makefile) may be adequate for small projects, especially those written in C or C++. If you need to handle dependencies, build-time configuration variables and other complications, you should look at [alternatives for C](http://www.shlomifish.org/open-source/resources/software-tools/) or the community-based alternatives for your programming language of choice (e.g: [setputools](http://en.wikipedia.org/wiki/Setuptools) for Python; [Dist::Zilla](http://dzil.org/) for Perl; [RubyGems](http://en.wikipedia.org/wiki/RubyGems) for Ruby).
4. Deploy a local or hosted [Continuous Integration](https://en.wikipedia.org/wiki/Continuous_integration) service and make sure that failing builds or tests are remedied.

For more information consult these links:

1. The essay [“What Makes Software High Quality?”](http://www.shlomifish.org/philosophy/computers/high-quality-software/rev2/)
2. The Perl Beginners’s Site [“Perl Elements to avoid”](http://perl-begin.org/tutorials/bad-elements/) and its spin-off [“C and C++ Elements to Avoid”](http://www.shlomifish.org/lecture/C-and-CPP/bad-elements/) (both of which have a lot of good advice related to other programming languages).
3. The tongue-in-cheek essay [“How To Write Unmaintable Code”](https://github.com/Droogans/unmaintainable-code) .
4. A [discussion](http://perlhacks.com/2012/03/you-must-hate-version-control-systems/) on Dave Cross’ Perl Hacks blog titled “You Must Hate Version Control Systems”.
5. [The Daily WTF](http://thedailywtf.com/) is a web site dedicated to posts about awful, but funny, programming practices.

###   What is the best programming language?

We sometimes get asked this question, and the answer is simple: there is none. Different languages have different strengths, weaknesses and often trade offs. You may wish to read the blog post [“(Why) Your Programming Language Must Suck”](http://shlomif-tech.livejournal.com/57811.html) for a short coverage of some of the important trade-offs a language design will have, and why no one will be happy with it all the time.

Even if we settle on a certain amount of preferences, then you may run into other factors that influence which language you may prefer:

1. Should the program run as quickly as possible? Or do you want to optimise for the developers’ time?
2. Is low memory consumption critical?
3. Should the language be portable to various operating systems and/or CPUs? Or is it OK if it only runs somewhere specific?
4. Should the language have an open-source implementation?
5. Should the language have a large user base, and provide quick and useful support?
6. Should bugs be addressed and fixed quickly in the implementations?
7. Should the language have any particular built-in features that you desire?
8. Should the language have an extensive library of extensions and APIs that can be reused?

Etc. If you tell us what your needs are, we can help you with a recommendation.

Note that some of the channel members happen to like a certain programming language in particular and tend to constantly recommend it to other people. Furthermore, you may run into language wars where one or more languages are bashed as awful languages by participants in the channel. That does not mean these languages are necessarily good or bad or suitable for what you wish to do.

###   What is the best [insert type of product with some alternatives]? What is the best and [insert adjective here]?

We also get asked this a lot and the answer is similar to the previous question: best in which respect? The various alternatives may have functionality trade-offs, and even if the factors are not at odds with one another, there can be remaining issues due to lack of developer time, policy, or design. Please tell us what exactly is the most important to you.

Note that "best and [insert adjective here]" is equally puzzling. Do you want the product with this property or do you also seek some other qualities?

###   What are good resources (including books) to learn about algorithms?

Here are some resources for learning about algorithms:

* [The Algorithm Design Manual](http://www.algorist.com/) by Steven Skiena. A good book and not a very technical one that provides a good introduction and reference for algorithms.
* [Wikipedia's list of data structures](http://en.wikipedia.org/wiki/List_of_data_structures) and [Wikipedia's list of algorithms](http://en.wikipedia.org/wiki/List_of_algorithms).
* [The Data Structures Wikibook](http://en.wikibooks.org/wiki/Data_Structures)
* The CC-by book [Open Data Structures](http://opendatastructures.org/).
* [The Book _Introduction to Algorithms_](http://en.wikipedia.org/wiki/Introduction_to_Algorithms) - by Cormen et. all (a.k.a “CLR” or “CLRS”) - a comprehensive reference on algorithms and data structures, but a technical and dry one.

There's also a [channel called "#algorithms" on Freenode](irc://irc.freenode.net/#algorithms) and, naturally, you can discuss algorithms on ##programming, as long as you perform due diligence.

### I have an awesome idea for a great project (probably a game) and I want people to help me…

First of all, we appreciate your enthusiasm, but you should realise that most of us have better things to do than help you (even if they are unemployed), and so you should offer money (and we don't mean a share of the profits.). If not, you are quite unlikely to recruit anyone.

If you cannot offer money, please consider learning the necessary skills yourself (see the above questions) and starting work on your own. If you make your project open-source and publicise it, then other people may eventually join you, and help you if they find it interesting.

###   What is the difference between “scripting” languages such as Perl, PHP, Python or Ruby and “Industrial-strength” Languages such as C, C++, Java and C#?

Many people have issues with calling dynamic languages, with dynamic typing and those that are of somewhat more open-source nature such as Perl, PHP, Python and Ruby as “scripting” languages. See:

* [Andy Lester's Stop saying “script”](http://xoa.petdance.com/Stop_saying_%22script%22)
* [Larry Wall’s “Programming’s Hard - Let’s Go Scripting”](http://www.perl.com/pub/2007/12/06/soto-11.html)
* [chromatic - “Program vs. Script”](http://use.perl.org/use.perl.org/_chromatic/journal/35804.html)

The problem with calling them that is that it is that while they allow for getting small and simple things done quickly and easily, large scale projects (100,000s to millions of lines of code) have been written in them and are still maintained without any show-stopping difficulties. That is not to say that these languages do not have their downsides, but they still do not preclude **general-purpose**, and/or **large-scale** programming.

Furthermore, if we consider Perl/PHP/Python/Ruby/Tcl/Lua/etc. as “scripting languages” and C, C++, Java and C# as “industrial strength” where does Common Lisp fit in? Where does Scheme? Where do Haskell and OCaml? What about the various dialects of Basic? Fortran? COBOL? It seems that the classification of languages as “scripting” vs “industrial strength” is more of that of public perception and marketing as opposed to their actual qualities.

On the other hand, we do not wish to claim here that C, C++, Java and/or C# are necessarily bad languages, or that you should not study them or refuse job offers that involve writing code using them.

###   I need to learn about various base systems, like hexadecimal (base-16), binary (base-2). Where can I find information about them?

See:

* [The English Wikipedia’s Binary Numeral System](https://en.wikipedia.org/wiki/Binary_numeral_system) - and the side bar next to it.
* [wikiHow’s How to Understand Hexadecimal](http://www.wikihow.com/Understand-Hexadecimal)

###   I want to buy some interesting books to read. Can you recommend me some?

Here are some lists of recommended books by some of our regulars:

* [Shlomi Fish’s Book Reviews](http://www.shlomifish.org/philosophy/books-recommends/)
* [vendu’s list of books](https://github.com/vendu/OS-Zero/blob/master/notes/booklist.txt)

In addition, here are some recommended lists of books by some notable software engineers and writers:

* [Joel on Software’s “Book Reviews”](http://www.joelonsoftware.com/navlinks/fog0000000262.html)

###   How do I learn how to use GDB (= the GNU debugger)?

We are often approached by people who tell us their C or C++ (or whatever) program crashes or otherwise misbehaves and then ask us why. If that's the case for you, you should realise that you should learn how to use an interactive debugger in order to debug your program, and you should learn how to do so as soon as possible.

One such debugger is the open source command-line debugger, "gdb", which can be used to debug programs in C, C++ and some other languages. Here is some information on learning to use it:

* [“Software Development on Linux” slides](http://www.shlomifish.org/lecture/W2L/Development/slides/) - a basic introduction to gdb.
* [“Advanced Debugging with gdb”](http://www.shlomifish.org/tel.foss.org.il-temp/lecture-notes/GDB_Linux_telux.pdf) - by David Khosid.
* [“gdb - customize it the way you want”](http://www.haifux.org/lectures/210/) - by guy keren.


###   I feel like programming something, but I don't know what. Can you suggest some good ideas for programs?

For some lists of ideas for what to program see:

* [“Links to Perl Exercises and Challenges” on Perl-Begin](http://perl-begin.org/exercises/) - not entirely Perl-specific.
* [“Problem Sets and Competitive Programming Sites”](https://github.com/vhf/free-programming-books/blob/master/problem-sets-competitive-programming.md) - a comprehensive list on GitHub.
* [Sphere Online Judge (SPOJ)](http://www.spoj.com/) - a site with many programming challenges.
* [“Ideas for Computing” by Samsquire](https://github.com/samsquire/ideas) - a list of advanced ideas.
* [“Hackerrank” - “Programming problems and competitions”](https://www.hackerrank.com/)
* [Anarchy Code Golf](http://golf.shinh.org/).

In addition, note that you may wish to consider contributing to open source projects that you find useful or interesting. For more information about that see:

* [“How to start contributing to or using open source software”](http://teachingopensource.org/index.php/How_to_start_contributing_to_or_using_Open_Source_Software)

###   I have a problem with my code, how should I share it for people to review?

First of all, your code should exhibit the problem you are having and should be a ''self-contained'', and ''reproducing'' example. If the code is too large, please consider reducing it to a more minimal example that still exhibits the problem (see the [bisection method](https://en.wikipedia.org/wiki/Bisection_method) ).

Once you have that, you have several options to share it. If you are coding a web page, you can try sharing your code using [jsfiddle](http://jsfiddle.net/) . Otherwise, if your code is self-contained in one file, you can use a paste site such as [ideone](http://ideone.com/) or [paste.debian.net](https://paste.debian.net/). Please don't floodpaste the code to the channel because this is slower and more annoying than using a paste site and may get you kicked or devoiced out of the channel.

If you have more than one file in the project, then you should put it in a self-contained version control repository on a code sharing site such as [GitHub](http://github.com/) , [Bitbucket](http://bitbucket.org/) , or [GitLab](https://about.gitlab.com/) , so we can easily clone or checkout it.

###   What is FizzBuzz?

In short, FizzBuzz is a simple programming task, which most decent programmers are expected to be able to easily write, but, reportedly, most interviewed software development candidates cannot write it. It's a kind of [litmus test](https://en.wiktionary.org/wiki/litmus_test) for programmers.

For more information, see:

* [Why Can’t Programmers Program?](http://blog.codinghorror.com/why-cant-programmers-program/)
* [FizzBuzz on Rosetta Code](http://rosettacode.org/wiki/FizzBuzz) (WARNING! The licence is problematic.)
* [FizzBuzz Enterprise Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)

### How are C, C++, and C# (C-sharp) related? How are they different?

* The [C Programming Language](https://en.wikipedia.org/wiki/C_%28programming_language%29) was created by Dennis Ritchie and other workers, and was used to write most of [UNIX](https://en.wikipedia.org/wiki/Unix). It is a kind of "mid-level" language because while it is above assembly, it is still lower-level than most other high-level languages.
* [C++](https://en.wikipedia.org/wiki/C%2B%2B) originated as some extensions to C to facilitate object-oriented programming (OOP) there, and has since developed many more extensions. C code can usually be compiled using a C++ compiler as is, but such code is no longer considered idiomatic C++. C and C++ can also call each other's routines, with relative ease.
* [Java](https://en.wikipedia.org/wiki/Java_%28programming_language%29) is a programming language whose syntax is superficially reminiscent of C, but which has otherwise different syntax, semantics (including garbage collection) and a completely different standard library.
* [C#](https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29) was inspired a lot by Java, and is very similar (but not compatible), and is not compatible with either C or C++. It is just sharing a name containing "C" for presumably marketing and branding purposes.
* [Managed C++](https://en.wikipedia.org/wiki/Managed_Extensions_for_C%2B%2B) is a C++-like language for [the .NET framework](https://en.wikipedia.org/wiki/.NET_Framework) (which is also used to host C#), which isn't entirely compatible with C++.

As a result, the term “the C family of languages” is confusing and should be avoided, in part because other languages not mentioned above may share similar syntax to C.

### I am facing a number of problems while using floating-point data types (e.g: "float" or "double"). Is there a explanation for this?

Computers use binary numbers because they’re faster at dealing with them, and because for most calculations, a tiny error in the 17th decimal place doesn’t matter at all since the numbers you work with aren’t round (or that precise) anyway. Moreover, because they use a binary floating point,they cannot represent a number like 0.1, 0.3, etc. accurately at all.

When the code is compiled, the floating point number is rounded to nearest number in the format, which results in rounding error even before the calculations. Furthermore, associativity in addition may result in different results: `a + (b + c) != (a + b) + c` and it is possible to get weird results like `a + b == a` if a’s exponent is much larger than b’s.

For more information, refer to these resources:

* [Floating point anomalies](http://floating-point-gui.de/) is a good resource for problems regarding floating point weird anamolies.
* [More weird problems](http://stackoverflow.com/questions/14859875/c-how-to-avoid-floating-point-arithmetic-error) faced while using floating point numbers.
* [Correction measures](http://stackoverflow.com/questions/590822/dealing-with-accuracy-problems-in-floating-point-numbers) to deal with floating point anamolies.
* [Accuracy of a float data-type](http://www.stata.com/support/faqs/data-management/float-data-type/)

### How do I hide/obscure/“encrypt” my source code to prevent end-users from learning how it works?

If you want to distribute some code you wrote and prevent end-users from
learning its inner working, there are a few things you need to be aware of.

The first is that there are [decompilers](http://en.wikipedia.org/wiki/Decompiler) and
that it is often possible for humans to do [reverse engineering](https://en.wikipedia.org/wiki/Reverse_engineering)
in order to determine the inner workings of a program to duplicate them. We
were told that there's a code-obfuscation technique that can usually prevent
that, but its downside is that the resultant code is much larger and much
slower (by a factor of about 100,000), so it'll likely be unacceptable to you.

The second is that some popular approaches for "hiding" the source code
are known to be ineffective - see [this post about distributing CPython's .pyc files](http://shlomif-tech.livejournal.com/39732.html) for an example.

The third is that a mostly failproof way to avoid revealing your code is to set up a world-wide-web service (or a different Networked service) for it and have the local end-user code query it using the network stack.

Another point is that you should consider trusting your users instead. Shlomi
Fish (“rindolf”) has a written a cautionary tale about the fact that [BitKeeper](https://en.wikipedia.org/wiki/BitKeeper)’s
parent company, BitMover, has done a series of licence changes to BitKeeper
over the years to prevent abuses from users who were unlikely to
become paid customers out of sheer paranoia in
[“What BitMover Got Wrong?”](http://better-scm.shlomifish.org/bk/what-bitmover-got-wrong.html), and you should better avoid it. Freenode is dedicated
to discussing collaborative and free/open projects and you are likely to
receive a lot of heat for not trusting your end users.

Finally, note that [Copyrights](https://en.wikipedia.org/wiki/Copyright) or
[software patents](https://en.wikipedia.org/wiki/Software_patent) may provide
adequate protection into people misappropriating the working of your code,
although they may be controversial (especially software patents). For more
information, see Eric Sink’s essay
[“Five Things Every Micro-ISV Should Know About Intellectual Property”](http://ericsink.com/articles/Intellectual_Property.html) .

### Who is the world’s best programmer?

We got asked several times who is world’s best programmer, so let’s try
to answer it once and for all. The first question we need to ask you is:
“Why does it matter?” If you knew who the best programmer in the world is,
do you think you can afford to hire him? Moreover, as [a post by Ovid notes](http://images.use.perl.org/use.perl.org/_Ovid/journal/39801.html),
studies found that the best programmers are only 5 times more
productive than the worst, which is consistent with productivity variation
in other fields. Furthermore, a contractor who did both web development
and Linux kernel development [noted](http://www.shlomifish.org/enough-with-sec/web-devel-has-become-too-hard.xhtml)
that despite common belief, “web development is harder than Linux kernel
development”.

Finally note that some software developers were able to contribute a lot to
the world of computing while writing only sub-optimal code. See the post
[“Why some Great Hackers Write Inelegant Code”](http://shlomif-tech.livejournal.com/33461.html).

The most important thing you can do is constantly try to improve your
programming skills, and learn from your fellow programmers, and from good
and bad code people wrote out there. One way to achieve that is to be present
on software development's forums, including ##programming .

### I printed something but don't see it on the console yet! My output is out-of-order? Help!

You may be suffering from buffering. First of all, go over Mark Jason Dominus’
[“Suffering from Buffering?”](http://perl.plover.com/FAQs/Buffering.html)
page which is somewhat focused on these issues for Perl 5. Then you may wish to:

1. In C, make a judicious use of [fflush()](http://en.cppreference.com/w/c/io/fflush), or use locks for synchronisation.
2. In C++, use [std::flush](http://stackoverflow.com/questions/14105650/how-does-stdflush-work).
3. Use similar routines for your programming language of choice.

### Is it true that ##programming is more about Anime than programming? (Just like #anime is more about programming than Anime)

That's not really true. While we sometimes discuss popular culture and entertainment (including but not limited to [Anime](https://en.wikipedia.org/wiki/Anime)) most of our conversations are about programming, or related computer help. It's not our fault that your favourite Anime-themed channel discusses programming a lot, and that may be caused by the fact that the IRC medium and Freenode in particular are somewhat more "techie"-oriented. So don't expect to join ##programming and hear many quality discussions about Anime.

## Licence/License

The textual content of this document is made available under the [Creative Commons Attribution 4.0 International licence](https://creativecommons.org/licenses/by/4.0/) (or at your option - any later version). Whatever code is given here is made available under the [MIT/Expat License](https://en.wikipedia.org/wiki/MIT_License). Share and enjoy!
